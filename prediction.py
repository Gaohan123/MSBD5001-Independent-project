import pandas as pd
from sklearn.preprocessing import StandardScaler
import math
import pickle

# load models trained before for ensemble
models = ['model_110.pickle', 'model_114.pickle',
                'model_134.pickle',
                'model_150.pickle', 'model_175.pickle', 'model_176.pickle']
model_dic = {}
for model in models:
    name = model[:9]
    with open(model, 'rb') as f:
        model = pickle.load(f)
    model_dic[name] = model

# Here I utilize train dataset given to fit scaler, which is necessary in both training and testing
df_source = pd.read_csv('train.csv')
df_final = pd.get_dummies(df_source.drop(columns = ['time']))
df_final = df_final.drop(columns = ['id'])
X_train = df_final
scaler = StandardScaler()
scaler.fit(X_train)

# make prediction
predict_results = []  # The list is used to collect results generated by every model for ensemble
for key in model_dic.keys():
    df_test = pd.read_csv('test.csv')
    df_final_test = df_test.drop(columns = ['id'])
    df_final_test = pd.get_dummies(df_final_test)  # transfer categorical variables into one-hot
    X_test = df_final_test
    X_test = scaler.transform(X_test)
    predict_result = pd.DataFrame(model_dic[key].predict(X_test), columns = ['time'])
    # Here as time cannot be negative value, I transfer negative prediction x into exp(x)
    for i in range(len(predict_result)):
        if predict_result.loc[i]['time'] < 0:
            predict_result.loc[i]['time'] = math.exp(predict_result.loc[i]['time'])
    # To prevent overfitting, I limit prediction value not exceeding 20.
    for i in range(len(predict_result)):
        if predict_result.loc[i]['time'] >20:
            predict_result.loc[i]['time'] = 20
    predict_results.append(predict_result)

# Get the mean value of all predictions as final results
predict_result_final = predict_results[0]
for i in range(1, len(predict_results)):
    predict_result_final = predict_result_final + predict_results[i]
predict_result_final = predict_result_final/len(models)

df = pd.DataFrame(list(range(100)), columns=['Id'])
predict_result_final.insert(0, 'Id', df)

# Save the final results as a csv file.
predict_result_final.to_csv("submission_hgaoaf.csv", index = False)